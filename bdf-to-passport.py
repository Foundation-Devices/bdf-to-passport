#!/Users/kenc/dev/juliet/passport-mp/ENV/bin/python

# Janky using the passport-mp pyenv, but whatever

import sys
from bdflib import reader

codepoint_ranges = [(32, 127), (177, 182), (215, 216)]
total_range = (32, 216)

def read_bdf_font(filename):
    with open(filename, "rb") as handle:
        font = reader.read_bdf(handle)
        return font

def write_header(output_file):
        output_file.write('''# Passport wallet font definitions
# Autogenerated by bdf-to-passport.py: DO NOT EDIT

from ucollections import namedtuple

GlyphInfo = namedtuple('GlyphInfo', 'x y w h bits')

# Lookup GlyphInfo for a single codepoint or return None
def lookup(font, cp):
    for r,d in font.codepoints:
        if cp not in r:
            continue
        ptr = d[cp-r.start]
        if not ptr:
            return None

        x, y, w, h, dlen = font.bboxes[font.bitmaps[ptr]]
        bits = font.bitmaps[ptr+1:ptr+1+dlen]

        return GlyphInfo(x, y, w, h, bits)
    return None

class FontBase:
    pass

''')

def print_font_properties(font):
    for prop in font.property_names():
        print("{} = {}".format(prop, font[prop]))
    
    print("Num codepoints = {}".format(len(font.codepoints())))

    for codepoint in font.codepoints():
        print(str(codepoint) + ", ", end="")

    # Print codepoint 65 as hex bytes
    letter_A = font[65]
    print(letter_A)
    print("[", end="")
    for b in letter_A.data:
        print("{0:#{1}x},".format(b, 2), end="")
    print("]")

    print("bbox: x={} y={} w={} h={}".format(letter_A.bbX, letter_A.bbY, letter_A.bbW, letter_A.bbH))

    foo = [0x41,0x41,0x41,0x7f,0x22,0x22,0x14,0x14,0x8,0x8,]

    print("\nDONE")

def split_str_into_groups_of_n(s, n):
    return [s[i:i+n] for i in range(0, len(s), n)]

# list of integers - oddly, these values have been shifted by the bbox X value
def format_row_data(row_data):
    return "xxx"
    # row_data is a list of ASCII-encoded numbers
    print("row_data={}".format(row_data))
    result = "{:x}".format(row_data)
    if len(result) % 2 == 1:
        result = "0{}".format(result)
    print(str(result))
    # Split every 2 characters
    arr = split_str_into_groups_of_n(result, 2)
    arr = [ascii_to_hex(i) for i in arr]


    result = ""
    for s in arr:
        result += "\\x{}".format(s)

    return result

def export_font(font, font_name, outfile):
    # print_font_properties(font)

    # available keys = [b'FACE_NAME', b'POINT_SIZE', b'RESOLUTION_X', b'RESOLUTION_Y', b'FONTNAME_REGISTRY', b'FOUNDRY', b'FAMILY_NAME',
    #    b'WEIGHT_NAME', b'SLANT', b'SETWIDTH_NAME', b'ADD_STYLE_NAME', b'SPACING', b'AVERAGE_WIDTH', b'CHARSET_REGISTRY',
    #    b'CHARSET_ENCODING', b'FONT_ASCENT', b'FONT_DESCENT', b'DEFAULT_CHAR', b'COPYRIGHT', b'X_HEIGHT', b'CAP_HEIGHT']
    outfile.write("class {}(FontBase):\n".format(font_name))
    outfile.write("    height = {}\n".format(int(font[b"POINT_SIZE"])))
    outfile.write("    advance = {}\n".format(int(font[b"AVERAGE_WIDTH"] // 10)))
    outfile.write("    ascent = {}\n".format(int(font[b"FONT_ASCENT"])))
    outfile.write("    descent = {}\n".format(int(font[b"FONT_DESCENT"])))
    # Standard leading is 25%
    outfile.write("    leading = {}\n".format(int(( (font[b"FONT_ASCENT"] + font[b"FONT_DESCENT"]) * 1.25 + 0.5)))) # Round up for leading
    outfile.write("    code_range = range({}, {})\n\n".format(total_range[0], total_range[1]))


    # Process the codepoints one by one
    bbox_dict = {}  # (x, y, w, h, data_len): offset
    next_bbox_offset = 1
    bitmaps = ""
    codepoints = ""
    bitmap_offset = 1

    for r in codepoint_ranges:
        codepoint_bitmap_offsets = []  # One offset for each codepoint

        for codepoint in range(r[0], r[1]):
            info = font[codepoint]
            data = info.get_data()  # Returns data as a list of arrays of ints, each of which represents a hex digit
            # data = info.data  # Return an array of integers, which can be arbitrary size
            num_rows = len(data)
            bytes_per_row = len(data[0]) // 2
            data_len = num_rows * bytes_per_row

            x = info.bbX
            y = info.bbY
            w = info.bbW
            h = info.bbH
            bbox = (x, y, w, h, data_len)
            bbox_offset = bbox_dict.get(bbox)
            if bbox_offset == None:
                # We haven't see this bbox shape before, so add it to the dict
                bbox_dict.update({bbox:next_bbox_offset})
                bbox_offset = next_bbox_offset
                next_bbox_offset += 1
            
            # Add bitmap offset to the codepoints range array
            codepoint_bitmap_offsets.append(bitmap_offset)

            # First byte in each codepoint entry is the offset to the bbox entry
            bitmaps += "0x{:02x}, # {} offset = {}\n        ".format(bbox_offset, info.name.decode('utf-8'), bitmap_offset)

            bitmap_offset +=  1 + data_len  # Add 1 because of the single-byte offset before the bitmap data that points to the bbox info

            # Then the bitmap bytes
            for b in data:
                s = "{}".format(b.decode('utf-8'))
                parts = split_str_into_groups_of_n(s, 2)
                for b in parts:
                    bitmaps += "0x{},".format(b)
            bitmaps += "\n\n        "

        # Add entries to the out_codepoints
        codepoints += "        (range({},{}), [".format(r[0], r[1])
        num_codepoints_written = 0
        for offset in codepoint_bitmap_offsets:
            codepoints += "{},".format(offset)
            num_codepoints_written += 1
            if num_codepoints_written == 16:
                codepoints += "\n            "
                num_codepoints_written = 0
        codepoints += "]),\n"

    # Output bounding boxes - map over the dict and sort in order of the mapped-to value
    outfile.write("    bboxes = [None,\n")
    bboxes = list(bbox_dict.items())
    bboxes.sort(key = lambda x: x[1])
    bboxes = [str(b[0]) for b in bboxes]
    for bbox in bboxes:
        outfile.write("       " + bbox + ",\n")
    outfile.write("    ]\n\n")

    # Output code_points
    outfile.write("    codepoints = [\n")
    for cp in codepoints:
        outfile.write(cp)

    outfile.write("    ]\n\n")

    # Output bitmaps
    outfile.write('    bitmaps = bytes([\n        0xAA, # Dummy first entry\n\n')
    outfile.write('        ' + bitmaps + "])\n\n")

def main():
    num_fonts = len(sys.argv) - 1
    if num_fonts < 1:
        print("Usage: bdf-to-passport <FontName>=<FontFilename> ...")
        print("    You must provide at least one font filename")
        sys.exit()

    # Hardcoded output file
    outfile = open("passport_fonts.py", "w")
    write_header(outfile)

    for i in range(1, num_fonts + 1):
        parts = sys.argv[i].split('=')
        font_name = parts[0]
        font_filename  = parts[1]

        print("Processing {} from file {}...".format(font_name, font_filename))
        font = read_bdf_font(font_filename)
        export_font(font, font_name, outfile)



if __name__ == '__main__':
   main()








# from ucollections import namedtuple

# GlyphInfo = namedtuple('GlyphInfo', 'x y w h bits')

# class FontBase:
#     pass


# class FontSmall(FontBase):
#     height = 14
#     code_range = range(32, 215)

#     @staticmethod
#     def lookup(cp):
#         # lookup glyph data for a single codepoint, or return None

#         bboxes = [None, (0, -3, 7, 14, 0), (0, -3, 7, 14, 4), (0, -3,
#   7, 14, 5), (0, -3, 7, 14, 7), (0, -3, 7, 14, 9), (0, -3, 7, 14, 10),
#   (0, -3, 7, 14, 11), (0, -3, 7, 14, 12), (0, -3, 7, 14, 13), (0, -3,
#   7, 14, 14)]

#         code_points = [
# (range(32, 127), [1, 2, 14, 20, 31, 43, 55, 67, 73, 87, 101, 111, 122,
#   136, 144, 157, 170, 182, 194, 206, 218, 230, 242, 254, 266, 278,
#   290, 303, 317, 329, 339, 351, 363, 375, 387, 399, 411, 423, 435,
#   447, 459, 471, 483, 495, 507, 519, 531, 543, 555, 567, 580, 592,
#   604, 616, 628, 640, 652, 664, 676, 688, 702, 715, 729, 734, 748,
#   754, 766, 778, 790, 802, 814, 826, 841, 853, 865, 879, 891, 903,
#   915, 927, 939, 953, 967, 979, 991, 1003, 1015, 1027, 1039, 1051,
#   1066, 1078, 1092, 1105, 1119]),
# (range(177, 182), [1125, 0, 0, 0, 1138]),  # ± µ
# (range(215, 216), [1151]),  # ×
#          ]

#         bitmaps = b"""\
# \xaa\x01\x07\x00\x10\x10\x10\x10\x10\x10\x10\x00\x10\x10\x03\x00\x28\x28\
# \x28\x28\x06\x00\x00\x24\x24\x7e\x24\x24\x7e\x24\x24\x07\x00\x00\x10\x3c\
# \x50\x50\x38\x14\x14\x78\x10\x07\x00\x22\x52\x54\x28\x08\x10\x14\x2a\x4a\
# \x44\x07\x00\x00\x30\x48\x48\x30\x30\x4a\x44\x44\x3a\x03\x00\x10\x10\x10\
# \x10\x09\x04\x08\x10\x10\x20\x20\x20\x20\x20\x10\x10\x08\x04\x09\x20\x10\
# \x08\x08\x04\x04\x04\x04\x04\x08\x08\x10\x20\x05\x00\x00\x00\x00\x24\x18\
# \x7e\x18\x24\x06\x00\x00\x00\x08\x08\x08\x3e\x08\x08\x08\x09\x00\x00\x00\
# \x00\x00\x00\x00\x00\x00\x18\x30\x20\x40\x04\x00\x00\x00\x00\x00\x00\x7e\
# \x08\x00\x00\x00\x00\x00\x00\x00\x00\x00\x10\x38\x10\x08\x02\x02\x04\x04\
# \x08\x08\x10\x10\x20\x20\x40\x40\x07\x00\x18\x24\x42\x42\x4a\x52\x42\x42\
# \x24\x18\x07\x00\x08\x18\x28\x48\x08\x08\x08\x08\x08\x08\x07\x00\x3c\x42\
# \x42\x02\x04\x08\x10\x20\x40\x7e\x07\x00\x3c\x42\x02\x02\x1c\x02\x02\x42\
# \x42\x3c\x07\x00\x0c\x14\x14\x24\x24\x44\x7e\x04\x04\x04\x07\x00\x7e\x40\
# \x40\x7c\x42\x02\x02\x02\x42\x3c\x07\x00\x3c\x42\x40\x40\x5c\x62\x42\x42\
# \x42\x3c\x07\x00\x7e\x02\x04\x04\x08\x08\x10\x10\x20\x20\x07\x00\x3c\x42\
# \x42\x42\x3c\x42\x42\x42\x42\x3c\x07\x00\x3c\x42\x42\x42\x46\x3a\x02\x02\
# \x42\x3c\x08\x00\x00\x00\x10\x38\x10\x00\x00\x00\x10\x38\x10\x09\x00\x00\
# \x00\x10\x38\x10\x00\x00\x00\x18\x30\x20\x40\x07\x00\x00\x04\x08\x10\x20\
# \x40\x20\x10\x08\x04\x05\x00\x00\x00\x00\x00\x7e\x00\x00\x7e\x07\x00\x00\
# \x20\x10\x08\x04\x02\x04\x08\x10\x20\x07\x00\x78\x04\x04\x08\x10\x20\x20\
# \x00\x20\x20\x07\x00\x1c\x22\x42\x4e\x52\x52\x52\x4e\x20\x1c\x07\x00\x3c\
# \x42\x42\x42\x42\x7e\x42\x42\x42\x42\x07\x00\x78\x44\x44\x44\x7c\x42\x42\
# \x42\x42\x7c\x07\x00\x3c\x42\x42\x40\x40\x40\x40\x42\x42\x3c\x07\x00\x78\
# \x44\x42\x42\x42\x42\x42\x42\x44\x78\x07\x00\x7e\x40\x40\x40\x7c\x40\x40\
# \x40\x40\x7e\x07\x00\x7e\x40\x40\x40\x7c\x40\x40\x40\x40\x40\x07\x00\x3c\
# \x42\x42\x40\x40\x4e\x42\x42\x42\x3c\x07\x00\x42\x42\x42\x42\x7e\x42\x42\
# \x42\x42\x42\x07\x00\x7c\x10\x10\x10\x10\x10\x10\x10\x10\x7c\x07\x00\x1e\
# \x02\x02\x02\x02\x02\x02\x42\x42\x3c\x07\x00\x42\x44\x48\x50\x68\x48\x44\
# \x44\x42\x42\x07\x00\x40\x40\x40\x40\x40\x40\x40\x40\x40\x7e\x07\x00\x42\
# \x66\x66\x5a\x5a\x5a\x42\x42\x42\x42\x07\x00\x42\x62\x62\x52\x52\x4a\x4a\
# \x46\x46\x42\x07\x00\x3c\x42\x42\x42\x42\x42\x42\x42\x42\x3c\x07\x00\x7c\
# \x42\x42\x42\x42\x7c\x40\x40\x40\x40\x08\x00\x3c\x42\x42\x42\x42\x42\x42\
# \x4a\x4a\x3c\x06\x07\x00\x7c\x42\x42\x42\x42\x7c\x50\x48\x44\x42\x07\x00\
# \x3c\x42\x40\x40\x30\x0c\x02\x02\x42\x3c\x07\x00\x7e\x08\x08\x08\x08\x08\
# \x08\x08\x08\x08\x07\x00\x42\x42\x42\x42\x42\x42\x42\x42\x42\x3c\x07\x00\
# \x42\x42\x42\x42\x42\x42\x24\x24\x18\x18\x07\x00\x42\x42\x42\x42\x42\x5a\
# \x5a\x5a\x24\x24\x07\x00\x42\x42\x24\x24\x18\x18\x24\x24\x42\x42\x07\x00\
# \x42\x42\x42\x42\x24\x18\x08\x08\x08\x08\x07\x00\x7e\x02\x04\x04\x08\x10\
# \x10\x20\x40\x7e\x09\x1e\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x10\x1e\
# \x08\x40\x40\x20\x20\x10\x10\x08\x08\x04\x04\x02\x02\x09\x78\x08\x08\x08\
# \x08\x08\x08\x08\x08\x08\x08\x08\x78\x02\x00\x18\x24\x42\x09\x00\x00\x00\
# \x00\x00\x00\x00\x00\x00\x00\x00\x00\x7e\x03\x00\x30\x18\x08\x04\x07\x00\
# \x00\x00\x00\x3c\x02\x3e\x42\x42\x46\x3a\x07\x00\x40\x40\x40\x5c\x62\x42\
# \x42\x42\x62\x5c\x07\x00\x00\x00\x00\x3c\x42\x40\x40\x40\x42\x3c\x07\x00\
# \x02\x02\x02\x3a\x46\x42\x42\x42\x46\x3a\x07\x00\x00\x00\x00\x3c\x42\x42\
# \x7e\x40\x40\x3e\x07\x00\x1c\x22\x20\x20\x20\x7c\x20\x20\x20\x20\x0a\x00\
# \x00\x00\x00\x3a\x46\x42\x42\x46\x3a\x02\x02\x42\x3c\x07\x00\x40\x40\x40\
# \x5c\x62\x42\x42\x42\x42\x42\x07\x00\x08\x08\x00\x38\x08\x08\x08\x08\x08\
# \x08\x09\x00\x04\x04\x00\x1c\x04\x04\x04\x04\x04\x04\x44\x38\x07\x00\x40\
# \x40\x40\x44\x48\x50\x70\x48\x44\x42\x07\x00\x20\x20\x20\x20\x20\x20\x20\
# \x20\x20\x1c\x07\x00\x00\x00\x00\x74\x4a\x4a\x4a\x4a\x42\x42\x07\x00\x00\
# \x00\x00\x5c\x62\x42\x42\x42\x42\x42\x07\x00\x00\x00\x00\x3c\x42\x42\x42\
# \x42\x42\x3c\x09\x00\x00\x00\x00\x5c\x62\x42\x42\x62\x5c\x40\x40\x40\x09\
# \x00\x00\x00\x00\x3a\x46\x42\x42\x46\x3a\x02\x02\x02\x07\x00\x00\x00\x00\
# \x5c\x62\x40\x40\x40\x40\x40\x07\x00\x00\x00\x00\x3c\x42\x40\x3c\x02\x42\
# \x3c\x07\x00\x00\x20\x20\x7c\x20\x20\x20\x20\x22\x1c\x07\x00\x00\x00\x00\
# \x42\x42\x42\x42\x42\x46\x3a\x07\x00\x00\x00\x00\x42\x42\x42\x24\x24\x18\
# \x18\x07\x00\x00\x00\x00\x42\x42\x4a\x4a\x4a\x5a\x24\x07\x00\x00\x00\x00\
# \x42\x24\x18\x00\x18\x24\x42\x0a\x00\x00\x00\x00\x42\x42\x42\x42\x46\x3a\
# \x02\x02\x42\x3c\x07\x00\x00\x00\x00\x7e\x02\x04\x08\x10\x20\x7e\x09\x06\
# \x08\x08\x08\x08\x08\x30\x08\x08\x08\x08\x08\x06\x08\x10\x10\x10\x10\x10\
# \x10\x10\x10\x10\x10\x10\x10\x09\x60\x10\x10\x10\x10\x10\x0c\x10\x10\x10\
# \x10\x10\x60\x03\x00\x00\x32\x4a\x44\x08\x00\x00\x00\x08\x08\x08\x7e\x08\
# \x08\x08\x00\x7e\x08\x00\x00\x00\x00\x44\x44\x44\x44\x4c\x7a\x40\x40\x06\
# \x00\x00\x00\x00\x42\x24\x18\x18\x24\x42\
# """
#         for r,d in code_points:
#             if cp not in r: continue
#             ptr = d[cp-r.start]
#             if not ptr: return None

#             x,y, w,h, dlen = bboxes[bitmaps[ptr]]
#             bits = bitmaps[ptr+1:ptr+1+dlen]

#             return GlyphInfo(x,y, w,h, bits)

#         return None
